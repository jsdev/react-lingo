{"ast":null,"code":"import { addDays, differenceInDays, formatISO, parseISO, startOfDay } from 'date-fns';\nimport { default as GraphemeSplitter } from 'grapheme-splitter';\nimport queryString from 'query-string';\nimport { ENABLE_ARCHIVED_GAMES } from '../constants/settings';\nimport { NOT_CONTAINED_MESSAGE, WRONG_SPOT_MESSAGE } from '../constants/strings';\nimport { VALID_GUESSES6 } from '../constants/validGuesses';\nimport { WORDS6 } from '../constants/wordlist';\nimport { getToday } from './dateutils';\nimport { getGuessStatuses } from './statuses'; // 1 January 2022 Game Epoch\n\nexport const firstGameDate = new Date(2022, 0);\nexport const periodInDays = 1;\n\nconst buildWordList = (words, validGuesses) => word => {\n  let lower_cased_word = localeAwareLowerCase(word);\n  return words.includes(lower_cased_word) || validGuesses.includes(lower_cased_word);\n};\n\nexport const isWordInWordList = buildWordList(WORDS6, VALID_GUESSES6);\nexport const isWinningWord = word => {\n  return solution === word;\n}; // build a set of previously revealed letters - present and correct\n// guess must use correct letters in that space and any other revealed letters\n// also check if all revealed instances of a letter are used (i.e. two C's)\n\nexport const findFirstUnusedReveal = (word, guesses) => {\n  if (guesses.length === 0) {\n    return false;\n  }\n\n  const lettersLeftArray = new Array();\n  const guess = guesses[guesses.length - 1];\n  const statuses = getGuessStatuses(solution, guess);\n  const splitWord = unicodeSplit(word);\n  const splitGuess = unicodeSplit(guess);\n\n  for (let i = 0; i < splitGuess.length; i++) {\n    if (statuses[i] === 'correct' || statuses[i] === 'present') {\n      lettersLeftArray.push(splitGuess[i]);\n    }\n\n    if (statuses[i] === 'correct' && splitWord[i] !== splitGuess[i]) {\n      return WRONG_SPOT_MESSAGE(splitGuess[i], i + 1);\n    }\n  } // check for the first unused letter, taking duplicate letters\n  // into account - see issue #198\n\n\n  let n;\n\n  for (const letter of splitWord) {\n    n = lettersLeftArray.indexOf(letter);\n\n    if (n !== -1) {\n      lettersLeftArray.splice(n, 1);\n    }\n  }\n\n  if (lettersLeftArray.length > 0) {\n    return NOT_CONTAINED_MESSAGE(lettersLeftArray[0]);\n  }\n\n  return false;\n};\nexport const unicodeSplit = word => {\n  return new GraphemeSplitter().splitGraphemes(word);\n};\nexport const unicodeLength = word => {\n  return unicodeSplit(word).length;\n};\nexport const localeAwareLowerCase = text => {\n  return process.env.REACT_APP_LOCALE_STRING ? text.toLocaleLowerCase(process.env.REACT_APP_LOCALE_STRING) : text.toLowerCase();\n};\nexport const localeAwareUpperCase = text => {\n  return process.env.REACT_APP_LOCALE_STRING ? text.toLocaleUpperCase(process.env.REACT_APP_LOCALE_STRING) : text.toUpperCase();\n};\nexport const getLastGameDate = today => {\n  const t = startOfDay(today);\n  let daysSinceLastGame = differenceInDays(firstGameDate, t) % periodInDays;\n  return addDays(t, -daysSinceLastGame);\n};\nexport const getNextGameDate = today => {\n  return addDays(getLastGameDate(today), periodInDays);\n};\nexport const isValidGameDate = date => {\n  if (date < firstGameDate || date > getToday()) {\n    return false;\n  }\n\n  return differenceInDays(firstGameDate, date) % periodInDays === 0;\n};\nexport const getIndex = gameDate => {\n  let start = firstGameDate;\n  let index = -1;\n\n  do {\n    index++;\n    start = addDays(start, periodInDays);\n  } while (start <= gameDate);\n\n  return index;\n};\nexport const getWordOfDay = (index, words) => {\n  if (index < 0) {\n    throw new Error('Invalid index');\n  }\n\n  return localeAwareUpperCase(words[index % words.length]);\n};\nexport const getRandomWord = words => localeAwareUpperCase(words[Math.floor(Math.random() * words.length)]);\nexport const getSolution = gameDate => {\n  const nextGameDate = getNextGameDate(gameDate);\n  const index = getIndex(gameDate);\n  const wordOfTheDay = getRandomWord(WORDS6); // getWordOfDay(index, WORDS6)\n\n  localStorage.given = wordOfTheDay[0];\n  return {\n    solution: wordOfTheDay,\n    solutionGameDate: gameDate,\n    solutionIndex: index,\n    tomorrow: nextGameDate.valueOf()\n  };\n};\nexport const getGameDate = () => {\n  if (getIsLatestGame()) {\n    return getToday();\n  }\n\n  const parsed = queryString.parse(window.location.search);\n\n  try {\n    const d = startOfDay(parseISO(parsed.d.toString()));\n\n    if (d >= getToday() || d < firstGameDate) {\n      setGameDate(getToday());\n    }\n\n    return d;\n  } catch (e) {\n    console.log(e);\n    return getToday();\n  }\n};\nexport const setGameDate = d => {\n  try {\n    if (d < getToday()) {\n      window.location.href = '/?d=' + formatISO(d, {\n        representation: 'date'\n      });\n      return;\n    }\n  } catch (e) {\n    console.log(e);\n  }\n\n  window.location.href = '/';\n};\nexport const getIsLatestGame = () => {\n  if (!ENABLE_ARCHIVED_GAMES) {\n    return true;\n  }\n\n  const parsed = queryString.parse(window.location.search);\n  return parsed === null || !('d' in parsed);\n};\nexport const {\n  solution,\n  solutionGameDate,\n  solutionIndex,\n  tomorrow\n} = getSolution(getGameDate());","map":{"version":3,"sources":["/Users/anthonydelorie/Git/react-wordle/src/lib/words.ts"],"names":["addDays","differenceInDays","formatISO","parseISO","startOfDay","default","GraphemeSplitter","queryString","ENABLE_ARCHIVED_GAMES","NOT_CONTAINED_MESSAGE","WRONG_SPOT_MESSAGE","VALID_GUESSES6","WORDS6","getToday","getGuessStatuses","firstGameDate","Date","periodInDays","buildWordList","words","validGuesses","word","lower_cased_word","localeAwareLowerCase","includes","isWordInWordList","isWinningWord","solution","findFirstUnusedReveal","guesses","length","lettersLeftArray","Array","guess","statuses","splitWord","unicodeSplit","splitGuess","i","push","n","letter","indexOf","splice","splitGraphemes","unicodeLength","text","process","env","REACT_APP_LOCALE_STRING","toLocaleLowerCase","toLowerCase","localeAwareUpperCase","toLocaleUpperCase","toUpperCase","getLastGameDate","today","t","daysSinceLastGame","getNextGameDate","isValidGameDate","date","getIndex","gameDate","start","index","getWordOfDay","Error","getRandomWord","Math","floor","random","getSolution","nextGameDate","wordOfTheDay","localStorage","given","solutionGameDate","solutionIndex","tomorrow","valueOf","getGameDate","getIsLatestGame","parsed","parse","window","location","search","d","toString","setGameDate","e","console","log","href","representation"],"mappings":"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","sourcesContent":["import {\n  addDays,\n  differenceInDays,\n  formatISO,\n  parseISO,\n  startOfDay,\n} from 'date-fns'\nimport { default as GraphemeSplitter } from 'grapheme-splitter'\nimport queryString from 'query-string'\n\nimport { ENABLE_ARCHIVED_GAMES } from '../constants/settings'\nimport { NOT_CONTAINED_MESSAGE, WRONG_SPOT_MESSAGE } from '../constants/strings'\nimport { VALID_GUESSES6 } from '../constants/validGuesses'\nimport { WORDS6 } from '../constants/wordlist'\nimport { getToday } from './dateutils'\nimport { getGuessStatuses } from './statuses'\n\n// 1 January 2022 Game Epoch\nexport const firstGameDate = new Date(2022, 0)\nexport const periodInDays = 1\n\nconst buildWordList =\n  (words: string[], validGuesses: string[]) => (word: string) => {\n    let lower_cased_word = localeAwareLowerCase(word)\n\n    return (\n      words.includes(lower_cased_word) ||\n      validGuesses.includes(lower_cased_word)\n    )\n  }\n\nexport const isWordInWordList = buildWordList(WORDS6, VALID_GUESSES6)\n\nexport const isWinningWord = (word: string) => {\n  return solution === word\n}\n\n// build a set of previously revealed letters - present and correct\n// guess must use correct letters in that space and any other revealed letters\n// also check if all revealed instances of a letter are used (i.e. two C's)\nexport const findFirstUnusedReveal = (word: string, guesses: string[]) => {\n  if (guesses.length === 0) {\n    return false\n  }\n\n  const lettersLeftArray = new Array<string>()\n  const guess = guesses[guesses.length - 1]\n  const statuses = getGuessStatuses(solution, guess)\n  const splitWord = unicodeSplit(word)\n  const splitGuess = unicodeSplit(guess)\n\n  for (let i = 0; i < splitGuess.length; i++) {\n    if (statuses[i] === 'correct' || statuses[i] === 'present') {\n      lettersLeftArray.push(splitGuess[i])\n    }\n    if (statuses[i] === 'correct' && splitWord[i] !== splitGuess[i]) {\n      return WRONG_SPOT_MESSAGE(splitGuess[i], i + 1)\n    }\n  }\n\n  // check for the first unused letter, taking duplicate letters\n  // into account - see issue #198\n  let n\n  for (const letter of splitWord) {\n    n = lettersLeftArray.indexOf(letter)\n    if (n !== -1) {\n      lettersLeftArray.splice(n, 1)\n    }\n  }\n\n  if (lettersLeftArray.length > 0) {\n    return NOT_CONTAINED_MESSAGE(lettersLeftArray[0])\n  }\n  return false\n}\n\nexport const unicodeSplit = (word: string) => {\n  return new GraphemeSplitter().splitGraphemes(word)\n}\n\nexport const unicodeLength = (word: string) => {\n  return unicodeSplit(word).length\n}\n\nexport const localeAwareLowerCase = (text: string) => {\n  return process.env.REACT_APP_LOCALE_STRING\n    ? text.toLocaleLowerCase(process.env.REACT_APP_LOCALE_STRING)\n    : text.toLowerCase()\n}\n\nexport const localeAwareUpperCase = (text: string) => {\n  return process.env.REACT_APP_LOCALE_STRING\n    ? text.toLocaleUpperCase(process.env.REACT_APP_LOCALE_STRING)\n    : text.toUpperCase()\n}\n\nexport const getLastGameDate = (today: Date) => {\n  const t = startOfDay(today)\n  let daysSinceLastGame = differenceInDays(firstGameDate, t) % periodInDays\n  return addDays(t, -daysSinceLastGame)\n}\n\nexport const getNextGameDate = (today: Date) => {\n  return addDays(getLastGameDate(today), periodInDays)\n}\n\nexport const isValidGameDate = (date: Date) => {\n  if (date < firstGameDate || date > getToday()) {\n    return false\n  }\n\n  return differenceInDays(firstGameDate, date) % periodInDays === 0\n}\n\nexport const getIndex = (gameDate: Date) => {\n  let start = firstGameDate\n  let index = -1\n  do {\n    index++\n    start = addDays(start, periodInDays)\n  } while (start <= gameDate)\n\n  return index\n}\n\nexport const getWordOfDay = (index: number, words: string[]) => {\n  if (index < 0) {\n    throw new Error('Invalid index')\n  }\n\n  return localeAwareUpperCase(words[index % words.length])\n}\n\nexport const getRandomWord = (words: string[]) =>\n  localeAwareUpperCase(words[Math.floor(Math.random() * words.length)])\n\nexport const getSolution = (gameDate: Date) => {\n  const nextGameDate = getNextGameDate(gameDate)\n  const index = getIndex(gameDate)\n  const wordOfTheDay = getRandomWord(WORDS6) // getWordOfDay(index, WORDS6)\n  localStorage.given = wordOfTheDay[0]\n\n  return {\n    solution: wordOfTheDay,\n    solutionGameDate: gameDate,\n    solutionIndex: index,\n    tomorrow: nextGameDate.valueOf(),\n  }\n}\n\nexport const getGameDate = () => {\n  if (getIsLatestGame()) {\n    return getToday()\n  }\n\n  const parsed = queryString.parse(window.location.search)\n  try {\n    const d = startOfDay(parseISO(parsed.d!.toString()))\n    if (d >= getToday() || d < firstGameDate) {\n      setGameDate(getToday())\n    }\n    return d\n  } catch (e) {\n    console.log(e)\n    return getToday()\n  }\n}\n\nexport const setGameDate = (d: Date) => {\n  try {\n    if (d < getToday()) {\n      window.location.href = '/?d=' + formatISO(d, { representation: 'date' })\n      return\n    }\n  } catch (e) {\n    console.log(e)\n  }\n  window.location.href = '/'\n}\n\nexport const getIsLatestGame = () => {\n  if (!ENABLE_ARCHIVED_GAMES) {\n    return true\n  }\n  const parsed = queryString.parse(window.location.search)\n  return parsed === null || !('d' in parsed)\n}\n\nexport const { solution, solutionGameDate, solutionIndex, tomorrow } =\n  getSolution(getGameDate())\n"]},"metadata":{},"sourceType":"module"}