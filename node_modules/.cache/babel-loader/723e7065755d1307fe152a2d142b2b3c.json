{"ast":null,"code":"import { addDays, differenceInDays, formatISO, parseISO, startOfDay } from 'date-fns';\nimport { default as GraphemeSplitter } from 'grapheme-splitter';\nimport queryString from 'query-string';\nimport { ENABLE_ARCHIVED_GAMES } from '../constants/settings';\nimport { NOT_CONTAINED_MESSAGE, WRONG_SPOT_MESSAGE } from '../constants/strings';\nimport { WORDS6 } from '../constants/wordlist';\nimport { getToday } from './dateutils';\nimport { getGuessStatuses } from './statuses'; // 1 January 2022 Game Epoch\n\nexport const firstGameDate = new Date(2022, 0);\nexport const periodInDays = 1;\nexport const isWordInWordList = (word, words, validGuesses) => {\n  let lower_cased_word = localeAwareLowerCase(word);\n  return words.includes(lower_cased_word) || validGuesses.includes(lower_cased_word);\n};\nexport const isWinningWord = word => {\n  return solution === word;\n}; // build a set of previously revealed letters - present and correct\n// guess must use correct letters in that space and any other revealed letters\n// also check if all revealed instances of a letter are used (i.e. two C's)\n\nexport const findFirstUnusedReveal = (word, guesses) => {\n  if (guesses.length === 0) {\n    return false;\n  }\n\n  const lettersLeftArray = new Array();\n  const guess = guesses[guesses.length - 1];\n  const statuses = getGuessStatuses(solution, guess);\n  const splitWord = unicodeSplit(word);\n  const splitGuess = unicodeSplit(guess);\n\n  for (let i = 0; i < splitGuess.length; i++) {\n    if (statuses[i] === 'correct' || statuses[i] === 'present') {\n      lettersLeftArray.push(splitGuess[i]);\n    }\n\n    if (statuses[i] === 'correct' && splitWord[i] !== splitGuess[i]) {\n      return WRONG_SPOT_MESSAGE(splitGuess[i], i + 1);\n    }\n  } // check for the first unused letter, taking duplicate letters\n  // into account - see issue #198\n\n\n  let n;\n\n  for (const letter of splitWord) {\n    n = lettersLeftArray.indexOf(letter);\n\n    if (n !== -1) {\n      lettersLeftArray.splice(n, 1);\n    }\n  }\n\n  if (lettersLeftArray.length > 0) {\n    return NOT_CONTAINED_MESSAGE(lettersLeftArray[0]);\n  }\n\n  return false;\n};\nexport const unicodeSplit = word => {\n  return new GraphemeSplitter().splitGraphemes(word);\n};\nexport const unicodeLength = word => {\n  return unicodeSplit(word).length;\n};\nexport const localeAwareLowerCase = text => {\n  return process.env.REACT_APP_LOCALE_STRING ? text.toLocaleLowerCase(process.env.REACT_APP_LOCALE_STRING) : text.toLowerCase();\n};\nexport const localeAwareUpperCase = text => {\n  return process.env.REACT_APP_LOCALE_STRING ? text.toLocaleUpperCase(process.env.REACT_APP_LOCALE_STRING) : text.toUpperCase();\n};\nexport const getLastGameDate = today => {\n  const t = startOfDay(today);\n  let daysSinceLastGame = differenceInDays(firstGameDate, t) % periodInDays;\n  return addDays(t, -daysSinceLastGame);\n};\nexport const getNextGameDate = today => {\n  return addDays(getLastGameDate(today), periodInDays);\n};\nexport const isValidGameDate = date => {\n  if (date < firstGameDate || date > getToday()) {\n    return false;\n  }\n\n  return differenceInDays(firstGameDate, date) % periodInDays === 0;\n};\nexport const getIndex = gameDate => {\n  let start = firstGameDate;\n  let index = -1;\n\n  do {\n    index++;\n    start = addDays(start, periodInDays);\n  } while (start <= gameDate);\n\n  return index;\n};\nexport const getWordOfDay = (index, words) => {\n  if (index < 0) {\n    throw new Error('Invalid index');\n  }\n\n  return localeAwareUpperCase(words[index % words.length]);\n};\nexport const getRandomWord = words => localeAwareUpperCase(words[Math.floor(Math.random() * words.length)]);\nexport const getSolution = gameDate => {\n  const nextGameDate = getNextGameDate(gameDate);\n  const index = getIndex(gameDate);\n  const wordOfTheDay = getRandomWord(WORDS6); // getWordOfDay(index, WORDS6)\n\n  localStorage.given = wordOfTheDay[0];\n  return {\n    solution: wordOfTheDay,\n    solutionGameDate: gameDate,\n    solutionIndex: index,\n    tomorrow: nextGameDate.valueOf()\n  };\n};\nexport const getGameDate = () => {\n  if (getIsLatestGame()) {\n    return getToday();\n  }\n\n  const parsed = queryString.parse(window.location.search);\n\n  try {\n    const d = startOfDay(parseISO(parsed.d.toString()));\n\n    if (d >= getToday() || d < firstGameDate) {\n      setGameDate(getToday());\n    }\n\n    return d;\n  } catch (e) {\n    console.log(e);\n    return getToday();\n  }\n};\nexport const setGameDate = d => {\n  try {\n    if (d < getToday()) {\n      window.location.href = '/?d=' + formatISO(d, {\n        representation: 'date'\n      });\n      return;\n    }\n  } catch (e) {\n    console.log(e);\n  }\n\n  window.location.href = '/';\n};\nexport const getIsLatestGame = () => {\n  if (!ENABLE_ARCHIVED_GAMES) {\n    return true;\n  }\n\n  const parsed = queryString.parse(window.location.search);\n  return parsed === null || !('d' in parsed);\n};\nexport const {\n  solution,\n  solutionGameDate,\n  solutionIndex,\n  tomorrow\n} = getSolution(getGameDate());","map":{"version":3,"sources":["/Users/anthonydelorie/Git/react-wordle/src/lib/words.ts"],"names":["addDays","differenceInDays","formatISO","parseISO","startOfDay","default","GraphemeSplitter","queryString","ENABLE_ARCHIVED_GAMES","NOT_CONTAINED_MESSAGE","WRONG_SPOT_MESSAGE","WORDS6","getToday","getGuessStatuses","firstGameDate","Date","periodInDays","isWordInWordList","word","words","validGuesses","lower_cased_word","localeAwareLowerCase","includes","isWinningWord","solution","findFirstUnusedReveal","guesses","length","lettersLeftArray","Array","guess","statuses","splitWord","unicodeSplit","splitGuess","i","push","n","letter","indexOf","splice","splitGraphemes","unicodeLength","text","process","env","REACT_APP_LOCALE_STRING","toLocaleLowerCase","toLowerCase","localeAwareUpperCase","toLocaleUpperCase","toUpperCase","getLastGameDate","today","t","daysSinceLastGame","getNextGameDate","isValidGameDate","date","getIndex","gameDate","start","index","getWordOfDay","Error","getRandomWord","Math","floor","random","getSolution","nextGameDate","wordOfTheDay","localStorage","given","solutionGameDate","solutionIndex","tomorrow","valueOf","getGameDate","getIsLatestGame","parsed","parse","window","location","search","d","toString","setGameDate","e","console","log","href","representation"],"mappings":"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","sourcesContent":["import {\n  addDays,\n  differenceInDays,\n  formatISO,\n  parseISO,\n  startOfDay,\n} from 'date-fns'\nimport { default as GraphemeSplitter } from 'grapheme-splitter'\nimport queryString from 'query-string'\n\nimport { ENABLE_ARCHIVED_GAMES } from '../constants/settings'\nimport { NOT_CONTAINED_MESSAGE, WRONG_SPOT_MESSAGE } from '../constants/strings'\nimport { VALID_GUESSES6 } from '../constants/validGuesses'\nimport { WORDS6 } from '../constants/wordlist'\nimport { getToday } from './dateutils'\nimport { getGuessStatuses } from './statuses'\n\n// 1 January 2022 Game Epoch\nexport const firstGameDate = new Date(2022, 0)\nexport const periodInDays = 1\n\nexport const isWordInWordList = (\n  word: string,\n  words: string[],\n  validGuesses: string[]\n) => {\n  let lower_cased_word = localeAwareLowerCase(word)\n\n  return (\n    words.includes(lower_cased_word) || validGuesses.includes(lower_cased_word)\n  )\n}\n\nexport const isWinningWord = (word: string) => {\n  return solution === word\n}\n\n// build a set of previously revealed letters - present and correct\n// guess must use correct letters in that space and any other revealed letters\n// also check if all revealed instances of a letter are used (i.e. two C's)\nexport const findFirstUnusedReveal = (word: string, guesses: string[]) => {\n  if (guesses.length === 0) {\n    return false\n  }\n\n  const lettersLeftArray = new Array<string>()\n  const guess = guesses[guesses.length - 1]\n  const statuses = getGuessStatuses(solution, guess)\n  const splitWord = unicodeSplit(word)\n  const splitGuess = unicodeSplit(guess)\n\n  for (let i = 0; i < splitGuess.length; i++) {\n    if (statuses[i] === 'correct' || statuses[i] === 'present') {\n      lettersLeftArray.push(splitGuess[i])\n    }\n    if (statuses[i] === 'correct' && splitWord[i] !== splitGuess[i]) {\n      return WRONG_SPOT_MESSAGE(splitGuess[i], i + 1)\n    }\n  }\n\n  // check for the first unused letter, taking duplicate letters\n  // into account - see issue #198\n  let n\n  for (const letter of splitWord) {\n    n = lettersLeftArray.indexOf(letter)\n    if (n !== -1) {\n      lettersLeftArray.splice(n, 1)\n    }\n  }\n\n  if (lettersLeftArray.length > 0) {\n    return NOT_CONTAINED_MESSAGE(lettersLeftArray[0])\n  }\n  return false\n}\n\nexport const unicodeSplit = (word: string) => {\n  return new GraphemeSplitter().splitGraphemes(word)\n}\n\nexport const unicodeLength = (word: string) => {\n  return unicodeSplit(word).length\n}\n\nexport const localeAwareLowerCase = (text: string) => {\n  return process.env.REACT_APP_LOCALE_STRING\n    ? text.toLocaleLowerCase(process.env.REACT_APP_LOCALE_STRING)\n    : text.toLowerCase()\n}\n\nexport const localeAwareUpperCase = (text: string) => {\n  return process.env.REACT_APP_LOCALE_STRING\n    ? text.toLocaleUpperCase(process.env.REACT_APP_LOCALE_STRING)\n    : text.toUpperCase()\n}\n\nexport const getLastGameDate = (today: Date) => {\n  const t = startOfDay(today)\n  let daysSinceLastGame = differenceInDays(firstGameDate, t) % periodInDays\n  return addDays(t, -daysSinceLastGame)\n}\n\nexport const getNextGameDate = (today: Date) => {\n  return addDays(getLastGameDate(today), periodInDays)\n}\n\nexport const isValidGameDate = (date: Date) => {\n  if (date < firstGameDate || date > getToday()) {\n    return false\n  }\n\n  return differenceInDays(firstGameDate, date) % periodInDays === 0\n}\n\nexport const getIndex = (gameDate: Date) => {\n  let start = firstGameDate\n  let index = -1\n  do {\n    index++\n    start = addDays(start, periodInDays)\n  } while (start <= gameDate)\n\n  return index\n}\n\nexport const getWordOfDay = (index: number, words: string[]) => {\n  if (index < 0) {\n    throw new Error('Invalid index')\n  }\n\n  return localeAwareUpperCase(words[index % words.length])\n}\n\nexport const getRandomWord = (words: string[]) =>\n  localeAwareUpperCase(words[Math.floor(Math.random() * words.length)])\n\nexport const getSolution = (gameDate: Date) => {\n  const nextGameDate = getNextGameDate(gameDate)\n  const index = getIndex(gameDate)\n  const wordOfTheDay = getRandomWord(WORDS6) // getWordOfDay(index, WORDS6)\n  localStorage.given = wordOfTheDay[0]\n\n  return {\n    solution: wordOfTheDay,\n    solutionGameDate: gameDate,\n    solutionIndex: index,\n    tomorrow: nextGameDate.valueOf(),\n  }\n}\n\nexport const getGameDate = () => {\n  if (getIsLatestGame()) {\n    return getToday()\n  }\n\n  const parsed = queryString.parse(window.location.search)\n  try {\n    const d = startOfDay(parseISO(parsed.d!.toString()))\n    if (d >= getToday() || d < firstGameDate) {\n      setGameDate(getToday())\n    }\n    return d\n  } catch (e) {\n    console.log(e)\n    return getToday()\n  }\n}\n\nexport const setGameDate = (d: Date) => {\n  try {\n    if (d < getToday()) {\n      window.location.href = '/?d=' + formatISO(d, { representation: 'date' })\n      return\n    }\n  } catch (e) {\n    console.log(e)\n  }\n  window.location.href = '/'\n}\n\nexport const getIsLatestGame = () => {\n  if (!ENABLE_ARCHIVED_GAMES) {\n    return true\n  }\n  const parsed = queryString.parse(window.location.search)\n  return parsed === null || !('d' in parsed)\n}\n\nexport const { solution, solutionGameDate, solutionIndex, tomorrow } =\n  getSolution(getGameDate())\n"]},"metadata":{},"sourceType":"module"}